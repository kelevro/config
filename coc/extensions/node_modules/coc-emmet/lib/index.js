"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const coc_nvim_1 = require("coc.nvim");
const defaultCompletionProvider_1 = require("./defaultCompletionProvider");
const util_1 = require("./util");
function activate(context) {
    registerCompletionProviders(context);
    context.subscriptions.push(coc_nvim_1.workspace.onDidChangeConfiguration(e => {
        if (e.affectsConfiguration('emmet.includeLanguages')) {
            registerCompletionProviders(context);
        }
    }));
    coc_nvim_1.workspace.onDidOpenTextDocument(() => {
        registerCompletionProviders(context);
    }, null, context.subscriptions);
}
exports.activate = activate;
/**
 * Holds any registered completion providers by their language strings
 */
const registeredModes = new Set();
function registerCompletionProviders(context) {
    let includedLanguages = util_1.getMappingForIncludedLanguages();
    let current_languages = coc_nvim_1.workspace.filetypes;
    for (let language of current_languages) {
        let emmetMode = Object.keys(util_1.LANGUAGE_MODES).find(s => s == language) || includedLanguages[language];
        if (!emmetMode || registeredModes.has(emmetMode))
            continue;
        registeredModes.add(emmetMode);
        let filetypes = [emmetMode];
        if (emmetMode != language) {
            filetypes.push(language);
        }
        for (let key of Object.keys(includedLanguages)) {
            let val = includedLanguages[key];
            if (val == emmetMode && filetypes.indexOf(val) == -1) {
                filetypes.push(val);
            }
        }
        let completionProvider = new defaultCompletionProvider_1.DefaultCompletionItemProvider();
        const provider = coc_nvim_1.languages.registerCompletionItemProvider(`emmet-${emmetMode}`, 'EM', filetypes, completionProvider, util_1.LANGUAGE_MODES[emmetMode]);
        context.subscriptions.push(provider);
    }
}
//# sourceMappingURL=index.js.map