"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
const coc_nvim_1 = require("coc.nvim");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const html_matcher_1 = tslib_1.__importDefault(require("@emmetio/html-matcher"));
const css_parser_1 = tslib_1.__importDefault(require("@emmetio/css-parser"));
const bufferStream_1 = require("./bufferStream");
exports.comparePosition = bufferStream_1.comparePosition;
let _emmetHelper;
let _currentExtensionsPath;
function positionInRange(position, range) {
    let { start, end } = range;
    if (bufferStream_1.comparePosition(position, start) < 0)
        return -1;
    if (bufferStream_1.comparePosition(position, end) > 0)
        return 1;
    return 0;
}
exports.positionInRange = positionInRange;
function getEmmetHelper() {
    // Lazy load emmet-helper instead of importing it
    // directly to reduce the start-up time of the extension
    if (!_emmetHelper) {
        _emmetHelper = require('vscode-emmet-helper');
    }
    updateEmmetExtensionsPath();
    return _emmetHelper;
}
exports.getEmmetHelper = getEmmetHelper;
/**
 * Update Emmet Helper to use user snippets from the extensionsPath setting
 */
function updateEmmetExtensionsPath() {
    if (!_emmetHelper) {
        return;
    }
    let extensionsPath = coc_nvim_1.workspace.getConfiguration('emmet')['extensionsPath'];
    if (_currentExtensionsPath !== extensionsPath) {
        _currentExtensionsPath = extensionsPath;
        _emmetHelper.updateExtensionsPath(extensionsPath, coc_nvim_1.workspace.rootPath).then(null, (err) => coc_nvim_1.workspace.showMessage(err, 'error'));
    }
}
exports.updateEmmetExtensionsPath = updateEmmetExtensionsPath;
/**
 * Mapping between languages that support Emmet and completion trigger characters
 */
exports.LANGUAGE_MODES = {
    'html': ['!', '.', '}', ':', '*', '$', ']', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
    'jade': ['!', '.', '}', ':', '*', '$', ']', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
    'slim': ['!', '.', '}', ':', '*', '$', ']', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
    'haml': ['!', '.', '}', ':', '*', '$', ']', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
    'xml': ['.', '}', '*', '$', ']', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
    'xsl': ['!', '.', '}', '*', '$', ']', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
    'css': [':', '-', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
    'scss': [':', '-', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
    'sass': [':', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
    'less': [':', '-', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
    'stylus': [':', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
    'javascriptreact': ['!', '.', '}', '*', '$', ']', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
    'typescriptreact': ['!', '.', '}', '*', '$', ']', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9']
};
function isStyleSheet(syntax) {
    let stylesheetSyntaxes = ['css', 'scss', 'sass', 'less', 'stylus', 'wxss'];
    return (stylesheetSyntaxes.indexOf(syntax) > -1);
}
exports.isStyleSheet = isStyleSheet;
function validate(allowStylesheet = true) {
    let doc = coc_nvim_1.workspace.getDocument(coc_nvim_1.workspace.bufnr);
    if (!doc)
        return false;
    if (!allowStylesheet && isStyleSheet(doc.filetype)) {
        return false;
    }
    return true;
}
exports.validate = validate;
function getMappingForIncludedLanguages() {
    // Explicitly map languages that have built-in grammar in VS Code to their parent language
    // to get emmet completion support
    // For other languages, users will have to use `emmet.includeLanguages` or
    // language specific extensions can provide emmet completion support
    const MAPPED_MODES = {
        'handlebars': 'html',
        'php': 'html'
    };
    const finalMappedModes = Object.create(null);
    let includeLanguagesConfig = coc_nvim_1.workspace.getConfiguration('emmet')['includeLanguages'];
    let includeLanguages = Object.assign({}, MAPPED_MODES, includeLanguagesConfig ? includeLanguagesConfig : {});
    Object.keys(includeLanguages).forEach(syntax => {
        if (typeof includeLanguages[syntax] === 'string' && exports.LANGUAGE_MODES[includeLanguages[syntax]]) {
            finalMappedModes[syntax] = includeLanguages[syntax];
        }
    });
    return finalMappedModes;
}
exports.getMappingForIncludedLanguages = getMappingForIncludedLanguages;
/**
* Get the corresponding emmet mode for given language mode
* Eg: jsx for typescriptreact/javascriptreact or pug for jade
* If the language is not supported by emmet or has been exlcuded via `exlcudeLanguages` setting,
* then nothing is returned
*
* @param language
* @param exlcudedLanguages Array of language ids that user has chosen to exlcude for emmet
*/
function getEmmetMode(language, excludedLanguages) {
    if (!language || excludedLanguages.indexOf(language) > -1) {
        return;
    }
    if (/\b(typescriptreact|javascriptreact|jsx-tags)\b/.test(language)) { // treat tsx like jsx
        return 'jsx';
    }
    if (language === 'sass-indented') { // map sass-indented to sass
        return 'sass';
    }
    if (language === 'jade') {
        return 'pug';
    }
    const emmetModes = ['html', 'pug', 'slim', 'haml', 'xml', 'xsl', 'jsx', 'css', 'scss', 'sass', 'less', 'stylus'];
    if (emmetModes.indexOf(language) > -1) {
        return language;
    }
    return;
}
exports.getEmmetMode = getEmmetMode;
/**
 * Parses the given document using emmet parsing modules
 */
function parseDocument(document, showError = true) {
    let parseContent = isStyleSheet(document.languageId) ? css_parser_1.default : html_matcher_1.default;
    try {
        return parseContent(new bufferStream_1.DocumentStreamReader(document));
    }
    catch (e) {
        if (showError) {
            console.error('Emmet: Failed to parse the file');
        }
    }
    return undefined;
}
exports.parseDocument = parseDocument;
const closeBrace = 125;
const openBrace = 123;
const slash = 47;
const star = 42;
/**
 * Traverse the given document backward & forward from given position
 * to find a complete ruleset, then parse just that to return a Stylesheet
 * @param document TextDocument
 * @param position Position
 */
function parsePartialStylesheet(document, position) {
    const isCSS = document.languageId === 'css';
    let startPosition = vscode_languageserver_protocol_1.Position.create(0, 0);
    let lastLine = document.getText(vscode_languageserver_protocol_1.Range.create(document.lineCount - 1, 0, document.lineCount, 0)).replace(/\n$/, '');
    let endPosition = vscode_languageserver_protocol_1.Position.create(document.lineCount - 1, lastLine.length);
    const limitCharacter = document.offsetAt(position) - 5000;
    const limitPosition = limitCharacter > 0 ? document.positionAt(limitCharacter) : startPosition;
    const stream = new bufferStream_1.DocumentStreamReader(document, position);
    function findOpeningCommentBeforePosition(pos) {
        let text = document.getText(vscode_languageserver_protocol_1.Range.create(0, 0, pos.line, pos.character));
        let offset = text.lastIndexOf('/*');
        if (offset === -1) {
            return;
        }
        return document.positionAt(offset);
    }
    function findClosingCommentAfterPosition(pos) {
        let text = document.getText(vscode_languageserver_protocol_1.Range.create(pos.line, pos.character, document.lineCount - 1, lastLine.length));
        let offset = text.indexOf('*/');
        if (offset === -1) {
            return;
        }
        offset += 2 + document.offsetAt(pos);
        return document.positionAt(offset);
    }
    function consumeLineCommentBackwards() {
        if (!isCSS && currentLine !== stream.pos.line) {
            currentLine = stream.pos.line;
            let line = document.getText(vscode_languageserver_protocol_1.Range.create(currentLine, 0, currentLine + 1, 0));
            let startLineComment = line.indexOf('//');
            if (startLineComment > -1) {
                stream.pos = vscode_languageserver_protocol_1.Position.create(currentLine, startLineComment);
            }
        }
    }
    function consumeBlockCommentBackwards() {
        if (stream.peek() === slash) {
            if (stream.backUp(1) === star) {
                stream.pos = findOpeningCommentBeforePosition(stream.pos) || startPosition;
            }
            else {
                stream.next();
            }
        }
    }
    function consumeCommentForwards() {
        if (stream.eat(slash)) {
            if (stream.eat(slash) && !isCSS) {
                stream.pos = vscode_languageserver_protocol_1.Position.create(stream.pos.line + 1, 0);
            }
            else if (stream.eat(star)) {
                stream.pos = findClosingCommentAfterPosition(stream.pos) || endPosition;
            }
        }
    }
    // Go forward until we find a closing brace.
    while (!stream.eof() && !stream.eat(closeBrace)) {
        if (stream.peek() === slash) {
            consumeCommentForwards();
        }
        else {
            stream.next();
        }
    }
    if (!stream.eof()) {
        endPosition = stream.pos;
    }
    stream.pos = position;
    let openBracesToFind = 1;
    let currentLine = position.line;
    let exit = false;
    // Go back until we found an opening brace. If we find a closing one, consume its pair and continue.
    while (!exit && openBracesToFind > 0 && !stream.sof()) {
        consumeLineCommentBackwards();
        switch (stream.backUp(1)) {
            case openBrace:
                openBracesToFind--;
                break;
            case closeBrace:
                if (isCSS) {
                    stream.next();
                    startPosition = stream.pos;
                    exit = true;
                }
                else {
                    openBracesToFind++;
                }
                break;
            case slash:
                consumeBlockCommentBackwards();
                break;
            default:
                break;
        }
        if (position.line - stream.pos.line > 100 || bufferStream_1.comparePosition(stream.pos, limitPosition) <= 0) {
            exit = true;
        }
    }
    // We are at an opening brace. We need to include its selector.
    currentLine = stream.pos.line;
    openBracesToFind = 0;
    let foundSelector = false;
    while (!exit && !stream.sof() && !foundSelector && openBracesToFind >= 0) {
        consumeLineCommentBackwards();
        const ch = stream.backUp(1);
        if (/\s/.test(String.fromCharCode(ch))) {
            continue;
        }
        switch (ch) {
            case slash:
                consumeBlockCommentBackwards();
                break;
            case closeBrace:
                openBracesToFind++;
                break;
            case openBrace:
                openBracesToFind--;
                break;
            default:
                if (!openBracesToFind) {
                    foundSelector = true;
                }
                break;
        }
        if (!stream.sof() && foundSelector) {
            startPosition = stream.pos;
        }
    }
    try {
        return css_parser_1.default(new bufferStream_1.DocumentStreamReader(document, startPosition, vscode_languageserver_protocol_1.Range.create(startPosition, endPosition)));
    }
    catch (e) {
        return;
    }
}
exports.parsePartialStylesheet = parsePartialStylesheet;
/**
 * Returns node corresponding to given position in the given root node
 */
function getNode(root, position, includeNodeBoundary) {
    if (!root) {
        return null;
    }
    let currentNode = root.firstChild;
    let foundNode = null;
    while (currentNode) {
        const nodeStart = currentNode.start;
        const nodeEnd = currentNode.end;
        if ((bufferStream_1.comparePosition(nodeStart, position) < 0 && bufferStream_1.comparePosition(nodeEnd, position) > 0)
            || (includeNodeBoundary && (bufferStream_1.comparePosition(nodeStart, position) <= 0 && bufferStream_1.comparePosition(nodeEnd, position) >= 0))) {
            foundNode = currentNode;
            // Dig deeper
            currentNode = currentNode.firstChild;
        }
        else {
            currentNode = currentNode.nextSibling;
        }
    }
    return foundNode;
}
exports.getNode = getNode;
exports.allowedMimeTypesInScriptTag = ['text/html', 'text/plain', 'text/x-template', 'text/template', 'text/ng-template'];
/**
 * Returns inner range of an html node.
 * @param currentNode
 */
function getInnerRange(currentNode) {
    if (!currentNode.close) {
        return undefined;
    }
    return vscode_languageserver_protocol_1.Range.create(currentNode.open.end, currentNode.close.start);
}
exports.getInnerRange = getInnerRange;
/**
 * Returns the deepest non comment node under given node
 * @param node
 */
function getDeepestNode(node) {
    if (!node || !node.children || node.children.length === 0 || !node.children.find(x => x.type !== 'comment')) {
        return node;
    }
    for (let i = node.children.length - 1; i >= 0; i--) {
        if (node.children[i].type !== 'comment') {
            return getDeepestNode(node.children[i]);
        }
    }
    return undefined;
}
exports.getDeepestNode = getDeepestNode;
function findNextWord(propertyValue, pos) {
    let foundSpace = pos === -1;
    let foundStart = false;
    let foundEnd = false;
    let newSelectionStart;
    let newSelectionEnd;
    while (pos < propertyValue.length - 1) {
        pos++;
        if (!foundSpace) {
            if (propertyValue[pos] === ' ') {
                foundSpace = true;
            }
            continue;
        }
        if (foundSpace && !foundStart && propertyValue[pos] === ' ') {
            continue;
        }
        if (!foundStart) {
            newSelectionStart = pos;
            foundStart = true;
            continue;
        }
        if (propertyValue[pos] === ' ') {
            newSelectionEnd = pos;
            foundEnd = true;
            break;
        }
    }
    if (foundStart && !foundEnd) {
        newSelectionEnd = propertyValue.length;
    }
    return [newSelectionStart, newSelectionEnd];
}
exports.findNextWord = findNextWord;
function findPrevWord(propertyValue, pos) {
    let foundSpace = pos === propertyValue.length;
    let foundStart = false;
    let foundEnd = false;
    let newSelectionStart;
    let newSelectionEnd;
    while (pos > -1) {
        pos--;
        if (!foundSpace) {
            if (propertyValue[pos] === ' ') {
                foundSpace = true;
            }
            continue;
        }
        if (foundSpace && !foundEnd && propertyValue[pos] === ' ') {
            continue;
        }
        if (!foundEnd) {
            newSelectionEnd = pos + 1;
            foundEnd = true;
            continue;
        }
        if (propertyValue[pos] === ' ') {
            newSelectionStart = pos + 1;
            foundStart = true;
            break;
        }
    }
    if (foundEnd && !foundStart) {
        newSelectionStart = 0;
    }
    return [newSelectionStart, newSelectionEnd];
}
exports.findPrevWord = findPrevWord;
function getEmmetConfiguration(syntax) {
    const emmetConfig = coc_nvim_1.workspace.getConfiguration('emmet');
    const syntaxProfiles = Object.assign({}, emmetConfig['syntaxProfiles'] || {});
    const preferences = Object.assign({}, emmetConfig['preferences'] || {});
    // jsx, xml and xsl syntaxes need to have self closing tags unless otherwise configured by user
    if (syntax === 'jsx' || syntax === 'xml' || syntax === 'xsl') {
        syntaxProfiles[syntax] = syntaxProfiles[syntax] || {};
        if (typeof syntaxProfiles[syntax] === 'object'
            && !syntaxProfiles[syntax].hasOwnProperty('self_closing_tag') // Old Emmet format
            && !syntaxProfiles[syntax].hasOwnProperty('selfClosingStyle') // Emmet 2.0 format
        ) {
            syntaxProfiles[syntax] = Object.assign({}, syntaxProfiles[syntax], { selfClosingStyle: 'xml' });
        }
    }
    return {
        preferences,
        showExpandedAbbreviation: emmetConfig['showExpandedAbbreviation'],
        showAbbreviationSuggestions: emmetConfig['showAbbreviationSuggestions'],
        syntaxProfiles,
        variables: emmetConfig['variables'],
        excludeLanguages: emmetConfig['excludeLanguages'],
        showSuggestionsAsSnippets: emmetConfig['showSuggestionsAsSnippets']
    };
}
exports.getEmmetConfiguration = getEmmetConfiguration;
/**
 * Itereates by each child, as well as nested child's children, in their order
 * and invokes `fn` for each. If `fn` function returns `false`, iteration stops
 */
function iterateCSSToken(token, fn) {
    for (let i = 0, il = token.size; i < il; i++) {
        if (fn(token.item(i)) === false || iterateCSSToken(token.item(i), fn) === false) {
            return false;
        }
    }
    return true;
}
exports.iterateCSSToken = iterateCSSToken;
/**
 * Returns `name` CSS property from given `rule`
 */
function getCssPropertyFromRule(rule, name) {
    return rule.children.find(node => node.type === 'property' && node.name === name);
}
exports.getCssPropertyFromRule = getCssPropertyFromRule;
function getEmbeddedCssNodeIfAny(document, currentNode, position) {
    if (!currentNode) {
        return;
    }
    const currentHtmlNode = currentNode;
    if (currentHtmlNode && currentHtmlNode.close) {
        const innerRange = getInnerRange(currentHtmlNode);
        if (innerRange && positionInRange(position, innerRange)) {
            if (currentHtmlNode.name === 'style'
                && bufferStream_1.comparePosition(currentHtmlNode.open.end, position) < 0
                && bufferStream_1.comparePosition(currentHtmlNode.close.start, position) > 0) {
                let buffer = new bufferStream_1.DocumentStreamReader(document, currentHtmlNode.open.end, vscode_languageserver_protocol_1.Range.create(currentHtmlNode.open.end, currentHtmlNode.close.start));
                return css_parser_1.default(buffer);
            }
        }
    }
    return;
}
exports.getEmbeddedCssNodeIfAny = getEmbeddedCssNodeIfAny;
function isStyleAttribute(currentNode, position) {
    if (!currentNode) {
        return false;
    }
    const currentHtmlNode = currentNode;
    const index = (currentHtmlNode.attributes || []).findIndex(x => x.name.toString() === 'style');
    if (index === -1) {
        return false;
    }
    const styleAttribute = currentHtmlNode.attributes[index];
    return bufferStream_1.comparePosition(position, styleAttribute.value.start) >= 0 && bufferStream_1.comparePosition(position, styleAttribute.value.end) <= 0;
}
exports.isStyleAttribute = isStyleAttribute;
//# sourceMappingURL=util.js.map